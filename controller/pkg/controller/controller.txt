package controller

import (
	"fmt"
	"strings"
	"sync"
	"time"

	osclient "github.com/openshift/origin/pkg/client"
	"github.com/openshift/origin/pkg/cmd/util/clientcmd"

	"github.com/spf13/pflag"
	kapi "k8s.io/kubernetes/pkg/api"
	"k8s.io/kubernetes/pkg/api/meta"
	kclient "k8s.io/kubernetes/pkg/client/unversioned"
	"k8s.io/kubernetes/pkg/runtime"
	"k8s.io/kubernetes/pkg/util/wait"
	"k8s.io/kubernetes/pkg/watch"
)

const (
	displayNameOldAnnotation = "displayName"
	displayNameAnnotation    = "openshift.io/display-name"
)

type Controller struct {
	openshiftClient *osclient.Client
	kubeClient      *kclient.Client
	mapper          meta.RESTMapper
	typer           runtime.ObjectTyper
	f               *clientcmd.Factory
}

type ScanImage struct {
	imageId		string
	taggedName 	string
}

const numScanners = 5

func New(os *osclient.Client, kc *kclient.Client) *Controller {

	f := clientcmd.New(pflag.NewFlagSet("empty", pflag.ContinueOnError))
	mapper, typer := f.Object()

	return &Controller{
		openshiftClient: os,
		kubeClient:      kc,
		mapper:          mapper,
		typer:           typer,
		f:               f,
	}
}


func (c *Controller) getImages (done <-chan struct{}) (<-chan ScanImage) {


	images := make(chan ScanImage)
/*
	imageList, err := c.openshiftClient.Images().List(kapi.ListOptions{})

	if err != nil {
		fmt.Println(err)
		return images
	}

	if imageList == nil {
		fmt.Println("No images")
		return images
	}

	for _, image := range imageList.Items {
		var imageItem ScanImage
		imageItem.imageId = image.DockerImageMetadata.ID

		tag := strings.Split(image.DockerImageReference, "@")
		imageItem.taggedName = tag[0]

		select {
			case images <- imageItem: 
			case <-done: 
				return nil
		}

	}
/*
	return images
}

func (c *Controller) Load(done <-chan struct{}) {

	fmt.Println ("Starting load of existing images ...")
	
	images := getImages( done )

	//ch := make(chan struct{}) 
	var wg sync.WaitGroup

	wg.Add(numScanners)
	for i := 0; i < numScanners; i++ {
		go func() {
			//scan(done, images, ch) 
			scan(done, images) 

			wg.Done()
		}()
	}
	go func() {
		wg.Wait()
		//close(ch) 
	}()

	fmt.Println ("Done load of existing images.")
	return
}

//func (c *Controller) scan (done <-chan struct{}, images chan<- ScanImage, ch <-chan struct{} ) {
func (c *Controller) scan (done <-chan struct{}, images chan<- ScanImage) {


}

func (c *Controller) Run(stopChan <-chan struct{}) {
	go wait.Until(func() {

		imageList, err := c.openshiftClient.Images().List(kapi.ListOptions{})

		if err != nil {
			fmt.Println(err)
		}

		if imageList == nil {
			fmt.Println("No images")
			return
		}

		for _, image := range imageList.Items {
			fmt.Println("Image: " + image.ObjectMeta.Name)
			// we could parse out a name from the schema2v1 manifest, but schema2v2 doesn't include the name so don't
			//fmt.Println("\tContainer: " + image.DockerImageManifest)

/*
    for k, v := range image.ObjectMeta.Annotations {
        fmt.Println("\t\tk:", k, "v:", v)
    }

    for k, v := range image.ObjectMeta.Labels {
        fmt.Println("\t\tk:", k, "v:", v)
    }
*/

			// actual docker image ID 
			fmt.Println("\tDocker ID: " + image.DockerImageMetadata.ID)
			// full qualified image name with digest
			fmt.Println("\tFully qualified image with digest: " + image.DockerImageReference )
			fmt.Println("")
			fmt.Println("docker run -ti --rm -v /var/run/docker.sock:/var/run/docker.sock --privileged 172.30.151.142:5000/blackduck/oc_scanner /scanner -h emea-saleshub.blackducksoftware.com -p 443 -s https -u tmackey -w blackduck -id " + image.DockerImageMetadata.ID)
			fmt.Println("")
		}

/*
		projectList, err := c.openshiftClient.Projects().List(kapi.ListOptions{})

		if err != nil {
			fmt.Println(err)
		}

		if projectList == nil {
			fmt.Println("No projects")
			return
		} else {
			for _, project := range projectList.Items {
				projectName := DisplayNameAndNameForProject(project.ObjectMeta)
				fmt.Println("Project: " + projectName)

				imageStreamList, err := c.openshiftClient.ImageStreams(projectName).List(kapi.ListOptions{})
				if err != nil {
					fmt.Println(err)
				}

				if imageStreamList == nil {
					fmt.Println ("\tNo image streams for project ", projectName )
				} else {

					for _, imageStream := range imageStreamList.Items {
						// actual docker image ID 
						fmt.Println("\tmeta name: " + imageStream.ObjectMeta.Name)
    for k, v := range imageStream.Spec.Tags {
        fmt.Println("\t\tName:", k, "Name:", v.Name)

    for k1, v1 := range v.Annotations {
        fmt.Println("\t\tk:", k1, "v:", v1)
    }

    }
						fmt.Println("\t\tImage repository: " + imageStream.Spec.DockerImageRepository)
    for k, v := range imageStream.ObjectMeta.Annotations {
        fmt.Println("\t\tk:", k, "v:", v)
    }

    for k, v := range imageStream.ObjectMeta.Labels {
        fmt.Println("\t\tk:", k, "v:", v)
    }

					}

				}
			}
		}

*/

/*
		w, err := c.kubeClient.Pods(kapi.NamespaceAll).Watch(kapi.ListOptions{})
		if err != nil {
			fmt.Println(err)
		}
		if w == nil {
			return
		}

		for {
			select {
			   case event, ok := <-w.ResultChan():
				c.ProcessEvent(event, ok)
			}
		}
*/
	}, 10000*time.Millisecond, stopChan)
}

func (c *Controller) ProcessEvent(event watch.Event, ok bool) {
	if !ok {
		fmt.Println("Error received from watch channel")
	}
	if event.Type == watch.Error {
		fmt.Println("Watch channel error")
	}

	var namespace string
	var runtime float64
	switch t := event.Object.(type) {
	case *kapi.Pod:
		podList, err := c.kubeClient.Pods(t.ObjectMeta.Namespace).List(kapi.ListOptions{})
		if err != nil {
			fmt.Println(err)
		}
		for _, pod := range podList.Items {
			runtime += c.TimeSince(pod.ObjectMeta.CreationTimestamp.String())
		}
		namespace = t.ObjectMeta.Namespace
	default:
		fmt.Printf("Unknown type\n")
	}
	fmt.Printf("Pods in namespace %v have been running for %v minutes.\n", namespace, runtime)
}

func (c *Controller) TimeSince(t string) float64 {
	startTime, err := time.Parse("2006-01-02 15:04:05 -0700 EDT", t)
	if err != nil {
		fmt.Println(err)
	}
	duration := time.Since(startTime)
	return duration.Minutes()
}



// DisplayNameAndNameForProject returns a formatted string containing the name
// of the project and includes the display name if it differs.
func DisplayNameAndNameForProject(project kapi.ObjectMeta) string {
	displayName := project.Annotations[displayNameAnnotation]
	
	if len(displayName) == 0 {
		displayName = project.Annotations[displayNameOldAnnotation]
	}

	if len(displayName) > 0 && displayName != project.Name {
		// we want the machine version, not the human readable one
		return project.Name
	}
	return project.Name
}
