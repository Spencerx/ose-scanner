package controller

import (
	"fmt"
	"strings"
	"sync"
	"time"

	osclient "github.com/openshift/origin/pkg/client"
	"github.com/openshift/origin/pkg/cmd/util/clientcmd"

	"github.com/spf13/pflag"
	kapi "k8s.io/kubernetes/pkg/api"
	"k8s.io/kubernetes/pkg/api/meta"
	kclient "k8s.io/kubernetes/pkg/client/unversioned"
	"k8s.io/kubernetes/pkg/runtime"
	//"k8s.io/kubernetes/pkg/util/wait"
	//"k8s.io/kubernetes/pkg/watch"
)

const (
	displayNameOldAnnotation = "displayName"
	displayNameAnnotation    = "openshift.io/display-name"
)

type HubParams struct {
	Host     string
	Port     string
	Scheme   string
	Username string
	Password string
	Scanner  string
}

type ScanImage struct {
	imageId		string
	taggedName 	string
}

type Job struct {
	ScanImage 	ScanImage
	controller	*Controller
}

var Hub HubParams

const numScanners = 5

var (
	MaxWorker = numScanners
	MaxQueue  = numScanners
)

type Controller struct {
	openshiftClient *osclient.Client
	kubeClient      *kclient.Client
	mapper          meta.RESTMapper
	typer           runtime.ObjectTyper
	f               *clientcmd.Factory
	jobQueue	chan Job
	wait		sync.WaitGroup
}

type Worker struct {
	id         	int
	jobQueue 	chan Job
	workerPool 	chan chan Job
	quit 		chan bool
}

type Dispatcher struct {
	// A pool of workers channels that are registered with the dispatcher
	jobQueue   chan Job
	workerPool chan chan Job
	maxWorkers int

}

func NewWorker (index int, workerPool chan chan Job) Worker {
	return Worker {
		id:		index,
		workerPool:	workerPool,
		jobQueue: 	make(chan Job),
		quit:		make(chan bool),
	}
}

func (w Worker) Start() {
	fmt.Printf ("Starting worker %d\n", w.id)
	
	go func() {
		for {
			w.workerPool <- w.jobQueue

			select {
				case job := <-w.jobQueue:
					if err := job.ScanImage.scan(); err != nil {
						fmt.Printf("Error scanning image: %s", err.Error())
					}
					job.Done()

				case <-w.quit:
					// we have received a signal to stop
					fmt.Printf ("Aborting worker %d\n", w.id)
					return
			}
		}
	}()
}

func (job Job) Done() {
	job.controller.wait.Done()
	return
}

func (job Job) Load() {
	job.controller.wait.Add(1)
	fmt.Println ("Queue image: " + job.ScanImage.taggedName)
	return
}



func (image ScanImage) scan () (err error){

	cmd := fmt.Sprintf ("docker run -ti --rm -v /var/run/docker.sock:/var/run/docker.sock --privileged %s /oc_scanner -h %s -p %s -s %s -u %s -w %s -id %s -tag %s", Hub.Scanner, Hub.Host, Hub.Port, Hub.Scheme, Hub.Username, Hub.Password, image.imageId, image.taggedName)

	fmt.Printf ("Scanning:\n\t%s\n", cmd)

	time.Sleep(10*time.Second)
	return nil
}

func NewDispatcher(jobQueue chan Job, maxWorkers int) *Dispatcher {
	pool := make(chan chan Job, maxWorkers)
	return &Dispatcher {
		jobQueue:   jobQueue,
		workerPool: pool,
		maxWorkers: maxWorkers,
	}
}

func (d *Dispatcher) Run() {
	// starting n number of workers
	for i := 0; i < d.maxWorkers; i++ {
		worker := NewWorker(i + 1, d.workerPool)
		worker.Start()
	}

	go d.dispatch()
}

func (d *Dispatcher) dispatch() {
	for {
		select {
			case job := <-d.jobQueue:
				// a job request has been received
				go func(job Job) {

					// try to obtain a worker job channel that is available.
					// this will block until a worker is idle
					workerJobQueue:= <-d.workerPool

					// dispatch the job to the worker job channel
					workerJobQueue <- job
				}(job)
		}
	}
}

func NewController(os *osclient.Client, kc *kclient.Client, hub HubParams) *Controller {

	f := clientcmd.New(pflag.NewFlagSet("empty", pflag.ContinueOnError))
	mapper, typer := f.Object()

	Hub = hub

	jobQueue := make(chan Job, MaxQueue)

	var wait sync.WaitGroup

	return &Controller{
		openshiftClient: os,
		kubeClient:      kc,
		mapper:          mapper,
		typer:           typer,
		f:               f,
		jobQueue:	 jobQueue,
		wait:		 wait,

	}
}

func (c *Controller) Start() {

	fmt.Println ("Starting controller")
	dispatcher := NewDispatcher(c.jobQueue, MaxWorker)
	dispatcher.Run()

	return
}

func (c *Controller) Stop() {

	fmt.Println ("Waiting for scan queue to drain before stopping...")
	c.wait.Wait()
	
	fmt.Println("Scan queue empty.")
	fmt.Println("Controller stopped.")
	return

}

func (c *Controller) Load(done <-chan struct{}) {

	fmt.Println ("Starting load of existing images ...")
	
	c.getImages( done )

	fmt.Println ("Done load of existing images.")

//	time.Sleep(2*time.Minute)
//	fmt.Println("Exit load")
	return
}

func (c *Controller) getImages (done <-chan struct{}) {

	imageList, err := c.openshiftClient.Images().List(kapi.ListOptions{})

	if err != nil {
		fmt.Println(err)
		return 
	}

	if imageList == nil {
		fmt.Println("No images")
		return
	}

	for _, image := range imageList.Items {
		var imageItem ScanImage
		imageItem.imageId = image.DockerImageMetadata.ID

		tag := strings.Split(image.DockerImageReference, "@")
		imageItem.taggedName = tag[0]
		
		job := Job {
			ScanImage: imageItem,
			controller: c,	
		}

		job.Load()
		c.jobQueue <- job

	}

	return 

}


// DisplayNameAndNameForProject returns a formatted string containing the name
// of the project and includes the display name if it differs.
func DisplayNameAndNameForProject(project kapi.ObjectMeta) string {
	displayName := project.Annotations[displayNameAnnotation]
	
	if len(displayName) == 0 {
		displayName = project.Annotations[displayNameOldAnnotation]
	}

	if len(displayName) > 0 && displayName != project.Name {
		// we want the machine version, not the human readable one
		return project.Name
	}
	return project.Name
}
